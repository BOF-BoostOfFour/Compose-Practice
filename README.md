공식 문서 [링크](https://developer.android.com/courses/pathways/jetpack-compose-for-android-developers-1?hl=ko)

# Compose 코드랩

# 첫번째 Compose 앱 만들기

### 시작하기 전에

- Jetpack Compose는 UI개발을 간소화하기 위해 설계
- 완전히 선언적인 접근 방식으로, 데이터를 UI 계층구조로 변환하는 함수를 호출하여 UI 구성
- 기본 데이터가 변경되면 프레임워크가 이러한 함수를 자동으로 다시 실행하여 UI 계층 구조를 업데이트
- Compose 앱은 Composable함수로 구성
- @Composable은 지속적으로 UI를 업데이트하고 유지관리하기 위해 함수에 특수 지원을 추가하도록 Compose에 알려주는 역할

### Compose 장점

- 코드 감소
    - 적은 수의 코드로 더 많은 작업을 하고 유지 관리하기 쉽다.
- 직관적
    - UI만 설명하면 나머지는 Compose에서 처리
    - 앱 상태가 변경되면 UI가 자동으로 업데이트
- 빠른 개발 과정
    - 기존의 모든 코드와 호환되고, 실시간 미리보기 지원

### **setContent**

- Activity에서 setContentView함수를 사용하는 것과 동일한 동작을 하는 확장함수이다. 다만, setContent의 경우 (@Composable) -> Unit 타입의 컴포즈 UI를 구현해주어야한다.

### Modifier

- Surface 및 Text와 같은 대부분의 Compose UI 요소는 modifier 매개변수를 선택적으로 허용
- 수정자는 상위 요소 레이아웃 내에서 UI요소가 배치되고 표시되고 동작하는 방식을 UI 요소에 알려준다.
- 예를 들어 padding 수정자는 수정자가 데코레이션 하는 요소 주변의 공간을나타댄다.
- 정렬, 애니메이션 처리, 배치, 클릭 가능 여부 또는 스크롤 가능 여부 지정, 변환 등에 사용 할 수 있는 수십 가지의 수정자가 있다.

### 컴포저블 재사용

- UI에 추가하는 구성요소가 많을수록 생성되는 중첩 레벨이 더 많아진다.
- 함수가 매우 커지면 가독성에 영향을 줄 수 있다.
- 재사용할 수 있는 구성요소를 만들면 앱에서 사용하는 UI요소의 라이브러리를 쉽게 만들 수 있다.
- 각 요소는 화면의 작은 부분을 담당하며 독립적으로 수정할 수 있다.
- 함수는 기본적으로 빈 수정자가 할당되는 수정자 매개변수를 포함하는것이 좋다. 이렇게하면 호출 사이트가, 컴포져블 함수 외부에서 레이아웃 안내와 동작을 조정할 수 있다.

### 열과 행 만들기

- Compose의 세 가지 기본 표준 레이아웃 요소는 Column, Row, Box이다.

### 후행 람다 전달

- Kotlin 규칙에 따르면 함수의 마지막 매개변수가 함수이면 해당 인수로 전달된 람다 표현식을 괄호 밖에 배치할 수 있습니다.

### Compose에서의 상태

- Compose 앱은 컴포져블 함수를 호출하여 데이터를 UI로 변환
- 데이터가 변경되면 Compose는 새 데이터로 이러한 함수를 다시 실행하여 업데이트된 UI를 만든다. 이를 리컴포지션이라고 한다.
- Compose는 데이터가 변경된 컴포넌트만 다시 구성하고 영향을 받지 않는 구성요소는 다시 구성하지않고 건너뛰도록 개별 컴포져블에서 필요한 데이터를 확인한다.

### 재구성

- 명령형 UI모델에서 위젯을 변경하려면 위젯에서 setter를 호출하여 내부 상태를 변경
- Compose에서는 새 데이터를 사용하여 컴포져블 함수를 다시 호출
    - Compsoe 프레임워크는 변경된 컴포넌트만 지능적으로 재구성
- 전체 UI 트리를 재구성하는 작업은 컴퓨팅 성능 및 배터리 수명을 사용한다는 측면에서 컴퓨팅 비용이 많이 들 수 있습니다. Compose는 이 *지능적 재구성*을 통해 이 문제를 해결합니다.
- 재구성은 입력이 변경될 때 구성 가능한 함수를 다시 호출하는 프로세스입니다. 이는 함수의 입력이 변경될 때 발생합니다. Compose는 새 입력을 기반으로 재구성할 때 변경되었을 수 있는 함수 또는 람다만 호출하고 나머지는 건너뜁니다. 매개변수가 변경되지 않은 함수 또는 람다를 모두 건너뜀으로써 Compose의 재구성이 효율적으로 이루어질 수 있습니다.

### 컴포져블 함수는 순서와 관계없이 실행할 수 있음

### 컴포져블 **함수는 동시에 실행할 수 있음**

- 컴포져블 함수가 백그라운드 스레드 풀 내에서 실행 될 수 있으므로, 어플리케이션이 올바르게 동작하려면 컴포져블 함수에 부작용이 없어야한다.
    - compose 함수 내부에서 외부에 있는 변수나, 동작에 영향을 주도록 구성되어서는 안 됩니다.
    - 이는 compose의 lifecycle에 의해서 recompose가 수시로 발생할 수 있고, 여러 thread에서 호출될 수 있기 때문입니다.
    - 하지만 Compose 내부의 동작으로 인하여 외부의 상태가 바뀌어야 하는 경우가 발생할 수 있기 때문에 이때는 Compose의 lifecycle을 인식하고, 이에 맞게 동작하는 형태로 구현 되어야 합니다.
    - 따라서 이런 지원을 하기 위해서 compostion이 완료될때 side-effect을 처리하는 composable function을 지원합니다. 이러한 composable function을 effect라는 단어로 정의하며, **effect란, UI를 방출하지 않는 composable function입니다.**
    - 반응형 UI는 기본적으로 비동기로 처리됩니다. **Compose는 이런 처리를 위하여 callback을 사용하지 않고 API level에서 corouitnes으로 감싸서 처리합니다.**
- 컴포져블 람다의 변수를 수정하는 코드를 피해야한다.

### 변수 트리거

- 컴포저블에 내부 상태를 추가하려면 `mutableStateOf` 함수를 사용하면 됩니다. 이 함수를 사용하면 Compose가 이 `State`를 읽는 함수를 재구성합니다.
    - `State` 및 `MutableState`는 어떤 값을 보유하고 그 값이 변경될 때마다 UI 업데이트(리컴포지션)를 트리거하는 인터페이스입니다.
- 하지만 **컴포저블 내의 변수에** `mutableStateOf`**를 할당하기만 할 수는 없습니다**. 앞에서 설명한 것처럼 `false` 값을 가진 변경 가능한 새 상태로 상태를 재설정하여 컴포저블을 다시 호출하는 때는 언제든지 리컴포지션이 일어날 수 있습니다.
- 여러 리컴포지션 간에 상태를 유지하려면 `remember`를 사용하여 변경 가능한 상태를 *기억*해야 합니다.
- 컴포져 함수는 상태를 자동으로 '구독'합니다. 상태가 변경되면 이러한 필드를 읽는 컴포저블이 재구성되어 업데이트를 표시합니다.

### ****상태 변경 및 상태 변경사항에 반응****

- 상태를 변경하기 위해 `Button`이 `onClick`이라는 매개변수를 사용한다고 알고 있을 수도 있지만, 값을 사용하지 않고 **함수를 사용합니다**.

### 상태 호이스팅

- 구성 가능한 함수에서 여러 함수가 읽거나 수정하는 상태는 공통의 상위 항목에 위치해야 합니다. 이 프로세스를 **상태 호이스팅**이라고 합니다. *호이스팅*이란 *들어 올린다* 또는 *끌어올린다*라는 의미입니다.
- 상태를 호이스팅할 수 있게 만들면 상태가 중복되지 않고 버그가 발생하는 것을 방지할 수 있으며 컴포저블을 재사용할 수 있고 훨씬 쉽게 테스트할 수 있습니다. 이에 반하여, 컴포저블의 상위 요소에서 제어할 필요가 없는 상태는 호이스팅되면 안 됩니다. **정보 소스**는 상태를 생성하고 관리하는 대상에 속합니다.

### **Statefull**

- remember 를 사용하여 객체를 저장하는 composable

### **Stateless**

- State를 갖지 않은 Composable
- State Hoisting 패턴 사용
- **단일 소스 저장소:** 상태를 복제하는 대신 옮겼기 때문에 소스 저장소가 하나만 있습니다. 버그 방지에 도움이 됩니다.
- **캡슐화됨:** 스테이트풀(Stateful) 컴포저블만 상태를 수정할 수 있습니다. 철저히 내부적 속성입니다.
- **공유 가능함:** 호이스팅한 상태를 여러 컴포저블과 공유할 수 있습니다. 다른 컴포저블에서 name을 사용하려는 경우 호이스팅을 통해 그렇게 할 수 있습니다.
- **가로채기 가능함:** 스테이트리스(Stateless) 컴포저블의 호출자는 상태를 변경하기 전에 이벤트를 무시할지 수정할지 결정할 수 있습니다.
- **분리됨:** 스테이트리스(Stateless) ExpandingCard의 상태는 어디에나 저장할 수 있습니다. 예를 들어 이제는 name을 ViewModel로 옮길 수 있습니다.

상태를 끌어올릴 때 상태의 이동 위치를 쉽게 파악할 수 있는 세 가지 규칙이 있습니다.

1. 상태는 *적어도* 그 상태를 사용하는 모든 컴포저블의 **가장 낮은 공통 상위 요소**로 끌어올려야 합니다(읽기).
2. 상태는 *최소한* **변경될 수 있는 가장 높은 수준**으로 끌어올려야 합니다(쓰기).
3. **동일한 이벤트에 대한 응답으로 두 상태가 변경**되는 경우 두 상태를 **함께 끌어올려야** 합니다.

**Stateless composable 은 Recomposition이 일어나지 않을수 있습니다.**

- state 의 변경이 없을경우 화면의 재구성이 발생하지 않습니다.
- Stateless Composable Parameter 에 인자가 전달 되더라도 참조 하지 않으면 Recomposition 이 발생하지 않습니다
