공식 문서 [링크](https://developer.android.com/courses/pathways/jetpack-compose-for-android-developers-1?hl=ko)

# 1. Compose 기본 사항

## 1.1 시작 튜토리얼

- Jetpack Compose는 네이티브 Android UI를 빌드하기 위한 최신 도구 키트
- Jetpack Compose는 더 적은 수의 코드, 강력한 도구, 직관적인 Kotlin API로 Android에서의 UI 개발을 간소화하고 가속화.

### 강의 1: 컴포져블한 함수

- Compose는 컴포져블 함수를 중심을 빌드
- 컴포져블 함수를 사용하면 UI의 구성 과정(요소 초기화, 상위 요소에 연결 등)에 집중하기 보다는 앱 모양을 설명하고 데이터 종속항목을 제공하여 프로그래미틱 방식으로 앱의 UI를 정의할 수 있다.
- 구성 가능한 함수를 만들려면 함수 이름에 `@Composable` 어노테이션을 추가

### 텍스트 요소 추가

- onCreate 메서드 내에서 텍스트 요소를 추가하려면 `setContent`블록을 정의하고 `Text`함수 호출
- `setContent` 은 컴포져블 함수가 호출되는 액티비티의 레이아웃을 정의
- 컴포져블 함수는 다른 컴포져블 함수에서만 호출할 수 있다.
- Jetpack Compose는 Kotlin 컴파일러 플러그인을 사용하여 컴포져블함수를 앱의 UI 요소로 변환합니다. 예를 들어, Compose UI 라이브러리에서 정의한 구성 가능한 `Text` 함수는 텍스트 라벨을 화면에 표시합니다.

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text("Hello world!")
        }
    }
}
```

### 컴포져블 함수 정의

- 함수를 컴포져블하게 하려면 `@Composable` 어노테이션을 추가

```kotlin
@Composable
fun MessageCard(name: String) {
    Text(text = "Hello $name!")
}
```

### Android 스튜디오에서 함수 미리보기

- `@Preview` 을 사용하면 앱을 빌드해서 Android 기기나 에뮬레이터에 설치하지 않고 Android 스튜디오 내에서 구성 가능한 함수를 미리 볼 수 있습니다.
- `@Preview` 는 매개변수를 사용하지 않는 컴포져블 함수에 사용해야 합니다.

## 1.2 Compose 이해

- jetpack Compose는 선언적 UI 프레임워크이며 xml에서 UI를 정의하고, 코드에서 xml에서 뷰를 찾은 다음 UI를 조작하는 setter 함수를 호출하는 것과 달리 xml을 작성할 필요가 없다.
- UI를 완전히 Kotlin으로 작성 가능 및 활용가능
- “어떻게”가 아닌 “무엇”을 설명함으로서 UI를 구성하는것이 Compose와 Views의 주요한 차이점이고 이것이 Compose를 직관적으로 만드는 요소

### 예시 “Jetsurvey” 설문 조사앱

*라디오 버튼이 있는 선택가능 투표 앱*

**기존 View를 사용할 경우** 

- 모든 view 요소들이 xml에 정의, UI상태를 변경하기 위해 kotlin에서 해당 뷰에 대한 참조를 얻고, set을 통해 원하는 UI를 표시
- 클릭 리스너 등을 통해 이벤트 발생시 뷰를 수동으로 업데이트 할 경우 오류가 발생하기 쉽고, configuration change이 발생할 경우 알맞은 로직을 다 넣어야 복원이 가능
- 뷰를 사용할때 configuration change에 라 동기화 하는것은 view 작업시 지속적인 과제고, 종속된 상태가 증가함에 따라 복잡성이 증가

**Compose를 사용할 경우** 

- 가로로 배치된 이미지, 텍스트 및 라디오 버튼이 있는 컨테이너를 비슷한 방식으로 구성
- UI를 설명할 때 xml 대신 코드를 직접 Kotlin으로 정의
- UI요소는 객체가 아닌 함수로서 완히 제어
- 뷰에 대한 참조를 찾고 해당 참조를 변형하는 메소드를 호출할 필요가 없다.
    - 원하는 UI 상태를 표시하기 위해 속성을 전달
- Views와는 달리 라디오 버튼은 자체 상태를 유지하지 않으며 사용자 이벤트로 인해 자동으로 변경되지 않습니다. 대신, 라디오 버튼 상태는 제공된 값에 의해 제어됩니다. 이것이 "what"과 "how"를 의미하는 것입니다.

**UI를 업데이트하기 위해 상태를 업데이트하는 방법**

- 사용자가 UI 요소와 상호 작용하면 UI는 “클릭”과 같은 이벤트를 발생
- 이벤트 처리기는 UI 상태를 변경할지 여부를 결정
- UI 상태가 변경되면 해당 상태에 의존하는 함수는 UI요소가 다시 실행되고 상태가 변경될 때 UI를 다시 생성하는 이 과정을 “recomposition”이라고 한다.

## 1.3 컴포져블 함수 및 “****Compose 이해” 문서 정리****

### 선언형 프로그래밍 패러다임

**XML**

- Compose 이전까지 Android 뷰 계층 구조는 UI 위젯의 트리로 표시
- 사용자 상호작용 등의 이유로 인해 앱의 상태가 변경되면 현재 데이터를 표시하기 위해 UI 계층구조를 업데이트해야 했다
- UI를 업데이트하는 가장 일반적인 방법은 `findViewById()`
- 뷰를 수동으로 조작하면 오류가 발생할 가능성이 크다.
- 데이터를 여러 위치에서 렌더링한다면 데이터를 표시하는 뷰 중 하나를 업데이트하는 것을 잊기 쉽다.
- 또한 두 업데이트가 예기치 않은 방식으로 충돌할 수 있다.
    - UI에서 삭제한 노드의 값을 설정할 경우

**Compose**

- UI 빌드 및 업데이트와 관련된 엔지니어링이 크게 간소화
- 화면 전체를 개념적으로 재생성한 후 필요한 변경사항만 적용하는 방식으로 작동
- Stateful 뷰계층구조를 수동으로 업데이트할 때의 복잡성을 방지
- 화면 전체를 재생성하는 데 있어 문제는 시간, 컴퓨팅 성능 및 배터리 사용량 측면에서 잠재적으로 비용이 많이 든다는 것입니다. 이 비용을 줄이기 위해 Compose는 특정 시점에 UI의 어떤 부분을 다시 그려야 하는지를 지능적으로 선택합니다
- @Composable은 아무것도 반환하지 않고, 멱등원이며 Side Effect가 없다.

### 선언형 패러다임 전환

- Compose의 선언형 접근 방식에서 위젯은 비교적 스테이트리스(Stateless) 상태이며 setter 또는 getter 함수를 노출하지 않습니다.
- 동일한 구성 가능한 함수를 다른 인수로 호출하여 UI를 업데이트합니다.
    - 이렇게 하여 viewModel과 같은 아키텍처 패턴에 State를 쉽게 제공
    - 그런 다음, 컴포저블은 식별 가능한 데이터가 업데이트될 때마다 현재 애플리케이션 상태를 UI로 변환합니다.
    
    
    앱 로직은 최상위의 구성 가능한 함수에 데이터를 제공합니다. 그러면 함수는 데이터를 사용하여 다른 컴포저블을 호출함으로써 UI를 형성하고 적절한 데이터를 해당 컴포저블 및 계층 구조 아래로 전달합니다.
    
- 사용자가 UI와 상호작용할 때 UI는 `onClick`과 같은 이벤트를 발생시킵니다. 이러한 이벤트를 앱 로직에 전달하여 앱의 상태를 변경해야 합니다. 상태가 변경되면 구성 가능한 함수는 새 데이터와 함께 다시 호출됩니다. 이렇게 하면 UI 요소가 다시 그려집니다. 이 프로세스를 *재구성*이라고 합니다.


사용자가 UI 요소와 상호작용하며 이에 따라 이벤트가 트리거됩니다. 앱 로직이 이벤트에 응답합니다. 그러면 구성 가능한 함수가 필요한 경우 새 매개변수를 사용하여 자동으로 다시 호출됩니다.

### 동적 콘텐츠

- 컴포져블 함수는 kotlin으로 작성되기 때문에 동적일 수 있다.

```kotlin
@Composable
fun Greeting(names: List<String>) {
    for (name in names) {
        Text("Hello $name")
    }
}
```

- if문을 호출하여 특정 UI를 표시할지 여부를 결정 할 수 있다.
    - 기본 언어의 유연성을 완전히 활용

### 재구성

- 명령형 UI 모델에서 위젯을 변경하려면 위젯에서 setter를 호출하여 내부 상태를 변경합니다.
- Compose에서는 새 데이터를 사용하여 구성 가능한 함수를 다시 호출합니다.
    - 이렇게 하면 함수가 *재구성*되며, 필요한 경우 함수에서 내보낸 위젯이 새 데이터로 다시 그려집니다.
    - Compose 프레임워크는 변경된 구성요소만 지능적으로 재구성할 수 있습니다.

```kotlin
@Composable
fun ClickCounter(clicks: Int, onClick: () -> Unit) {
    Button(onClick = onClick) {
        Text("I've been clicked $clicks times")
    }
}
```

- 버튼이 클릭될때마다 호출자는 clicks 값을 업데이트하고 Compse는 Text함수를 사용해 람다를 다시 호출하여 새 값을 표시
    - 이 프로세스를 재구성이라고 하고 값에 종속되지 않은 다른 함수는 재구성되지 않는다.

함수의 재구성을 건너뛸 수 있으므로 컴포져블 함수 실행의 부작용에 의존해서는 안 됩니다. 그렇게 하면 사용자가 앱에서 이상하고 예측할 수 없는 동작을 경험할 수 있습니다. 부작용은 앱의 나머지 부분에 표시되는 변경사항입니다. 예를 들어 다음 작업은 모두 위험한 부작용입니다.

- 공유 객체의 속성에 쓰기
- `ViewModel`에서 식별 가능한 요소 업데이트
- 공유 환경설정 업데이트

컴포져블 함수는 애니메이션이 렌더링될 때와 같이 모든 프레임에서와 같은 빈도로 재실행될 수 있으므로 버벅거림을 방지하기위해 비용이 많이 드는 작업을 실행 할 경우 백그라운드 코루틴에서 작업을 실행하고 값 결과를 컴포져블 함수에 매개변수로 전달해야 한다.

### Compose에서 프로그래밍할 때 알아야 할 사항

- **컴포져블 함수는 순서와 관계없이 실행할 수 있습니다.**
    - 컴포져블 함수는 순서와 관계없이 실행될 수있다.
    - Compose에는 일부 UI요소가 다른 UI보다 우선순위가 높다는 것을 인식하고 그 요소를 먼저 그리는 옵션이 있다.
- **컴포져블 함수는 동시에 실행할 수 있습니다.**
    - Compose는 컴포져블함수를 동시에 실행하여 재구성을 최적화할 수 있습니다. 이를 통해 Compose는 다중 코어를 활용하고 화면에 없는 구성 가능한 함수를 낮은 우선순위로 실행할 수 있습니다.
    - 이 최적화는 구성 가능한 함수가 백그라운드 스레드 풀 내에서 실행될 수 있음을 의미합니다. 구성 가능한 함수가 `ViewModel`에서 함수를 호출하면 Compose는 동시에 여러 스레드에서 이 함수를 호출할 수 있습니다.
    - 따라서 올바르게 작동하기 위해 컴포져블 함수에 부작용이없어야한다.
        - 즉 컴포져블 함수의 변수를 수정하는 코드를 피해야한다.
- **재구성은 최대한 많은 수의 구성 가능한 함수 및 람다를 건너뜁니다.**
    - UI 업데이트시 Compose는 업데이트해야 하는 부분만 재구성
- **재구성은 낙관적이며 취소될 수 있습니다.**
- **구성 가능한 함수는 애니메이션의 모든 프레임에서와 같은 빈도로 매우 자주 실행될 수 있습니디.**
    - 경우에 따라 컴포져블 함수는 UI 애니메이션의 모든 프레임에서 실행될 수 있습니다. 함수가 기기 저장소에서 읽기와 같이 비용이 많이 드는 작업을 실행하면 이 함수로 인해 UI 버벅거림이 발생할 수 있다.
    - 컴포져블 함수에 데이터가 필요하다면 데이터의 매개변수를 정의해야 합니다. 그런 다음, 비용이 많이 드는 작업을 구성 외부의 다른 스레드로 이동하고 `mutableStateOf` 또는 `LiveData`를 사용하여 Compose에 데이터를 전달할 수 있습니다.

## 1.4 첫 번째 Compose 앱 만들기

- 상태, 레이아웃, 테마 설정을 사용하여 선언적 UI의 기본사항을 직접 사용해보고 관련 내용을 학습합니다. 이를 통해 컴포저블과 수정자가 무엇인지 알아보고, 행 및 열과 같은 기본 UI 요소를 사용하는 방법과 앱에 상태를 지정하는 방법을 알 수 있습니다.

## 1.5 Compose UI 도구 키트

- TODO 동영상 정리

## 1.6 실제 디자인 구현

- code lab

## 1.7 상태 시작하기

- Codelab
